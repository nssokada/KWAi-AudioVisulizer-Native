package sample;/* autogenerated by Processing revision 1281 on 2022-04-16 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.awt.PSurfaceAWT;
import java.awt.MouseInfo;
import java.awt.Point;
import ddf.minim.*;
import ddf.minim.analysis.*;
import ddf.minim.effects.*;
import ddf.minim.signals.*;
import ddf.minim.spi.*;
import ddf.minim.ugens.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Relaxed extends PApplet {











// Configuration variables
// ------------------------
int canvasWidth = 1080;
int canvasHeight = 1080;
String audioFileName = "ThetaAlpha.mp3"; // Audio file in data folder

//Global variables: 
float fps = 200; 
float smoothingFactor = 0.25f;
AudioPlayer player;
FFT fft;
Minim minim;
int bands = 256; // must be multiple of two
float[] spectrum = new float[bands];
float[] sum = new float[bands];
float unit;
int groundLineY;
int sphereRadius;
float spherePrevX;
float spherePrevY;
int yOffset;
boolean initialStatic = true;
float[] extendingSphereLinesRadius;
PVector center;
float var1;
float var2;
boolean isInFullscreen;
boolean dragging;
int dragX, dragY;
Button hide, full, close;
PSurfaceAWT awtSurface;
PSurfaceAWT.SmoothCanvas smoothCanvas;

//Main Setup:
 public void settings() {
  size(canvasWidth, canvasHeight);
  smooth(8);
}

 public void setup(){
  background(0);
  frameRate(30);
  surface.setResizable(true);
  noStroke();

  //fullScreen();
  //surface.setSize(1080,1080);
  ////noCursor(); 
  
  // Graphics related variable setting
  unit = height / 100; // Everything else can be based around unit to make it change depending on size 
  strokeWeight(unit / 10.24f);
  groundLineY = height * 3/4;
  center = new PVector(width / 2, height * 3/4); 
  
  //AUDIO PROCESSING DONE HERE.
  minim = new Minim(this);
  player = minim.loadFile("ThetaAlpha.mp3");    
  player.loop();
  fft = new FFT( player.bufferSize(), player.sampleRate() );
  fft.linAverages(256);
  
  awtSurface = (PSurfaceAWT)surface;
  smoothCanvas = (PSurfaceAWT.SmoothCanvas)awtSurface.getNative();
  smoothCanvas.getFrame().removeNotify();
  smoothCanvas.getFrame().setUndecorated(true);// Hide the window border
  smoothCanvas.getFrame().setLocation(100, 100);// Move the window
  smoothCanvas.getFrame().addNotify();
  
  // Menu Buttons
  hide = new Button(width - 115, -5, 40, 25, color(0xFFFFFF66), 5);
  full = new Button(width - 80, -5, 40, 25, color(0xFF99FF66), 5);
  close = new Button(width - 45, -5, 50, 25, color(200, 0, 0), 5);
}

 public void drawStatic(){
  if(initialStatic){
    extendingSphereLinesRadius = new float[241];
 
    for (int angle = 0; angle <= 240; angle += 4) {
      extendingSphereLinesRadius[angle] = map(random(1), 0, 1, sphereRadius, sphereRadius * 7);
    }
    initialStatic = false;
  }
  //more extending lines:
  for (int angle = 0; angle <= 240; angle += 4) {
    float x = round(cos(radians(angle + 150)) * sphereRadius + center.x);
    float y = round(sin(radians(angle + 150)) * sphereRadius + groundLineY - yOffset);
    float xDestination = x;
    float yDestination = y;
  
  for (int i = sphereRadius; i <= extendingSphereLinesRadius[angle]; i++) {
      float x2 = cos(radians(angle + 150)) * i + center.x;
      float y2 = sin(radians(angle + 150)) * i + groundLineY - yOffset;
 
      if (y2 <= getGroundY(x2)) { // Make sure it doesn't go into the ground
        xDestination = x2;
        yDestination = y2;
      }
    }
  stroke(255);
  //The following creates the static not moving lines extending from a sphere:
  if (y <= getGroundY(x) && y % 2 == 0){
      stroke(0xFF00FFBF , 200);//cool green
      line(x, y, xDestination, yDestination);
  }else{
    stroke(0xFFFFFFFF, 200);//cool blue
    line(x, y, xDestination, yDestination);
  }
  }
}

//The waves in the back:
 public void drawAll(float[] sum) {
  sphereRadius = 15 * round(unit);
  spherePrevX = 0;
  spherePrevY = 0;
  yOffset = round(sin(radians(150)) * sphereRadius);
  drawStatic();
  float x = 0;
  float y = 0;
  int surrCount = 1;
  boolean direction = false;
  while (x < width * 1.5f && x > 0 - width / 2){
    float surroundingRadius;
    float surrRadMin = sphereRadius + sphereRadius * 1/2 * surrCount;
    float surrRadMax = surrRadMin + surrRadMin * 1/8;
    float surrYOffset;
    float addon = frameCount * 1.5f;
    if(direction) addon = addon * 1.5f;
    
    //audio.bufferSize() - 1 dancing circular waves in the back
    for (float angle = 0; angle <= 240; angle += 1.5f){
      surroundingRadius = map(sin(radians(angle * 7 + addon)), -1, 1, surrRadMin, surrRadMax); // Faster rotation through angles, radius oscillates
      surrYOffset = sin(radians(150)) * surroundingRadius;
      x = round(cos(radians(angle + 150)) * surroundingRadius + center.x);
      y = round(sin(radians(angle + 150)) * surroundingRadius + getGroundY(x) - surrYOffset);
      noStroke();
      fill(map(surroundingRadius, surrRadMin, surrRadMax, 100, 255));
      if( angle % 2 == 0) {
        fill(0xFF00FFBF , 200);//cool green
        circle(x, y, 3* unit / 10.24f);
        noFill();
      } else {
        fill(0xFF00FFFF, 200); //cool blue
        circle(x, y, 3* unit / 10.24f);
        noFill();
      }
    }
    
    ////sound sphere in the middle:
    ////241 or player.bufferSize() - 1
    for (int i = 0; i < 240; i++){
      float angle = sin(i+var1)* unit; 
      float angle2 = sin(i+var2)* unit*30; 
      float x5 = round(cos(radians(i+150))*(200/angle2+sphereRadius)+center.x); 
      float y5 = round(sin(radians(i+var2))*(200/angle2+sphereRadius)+ groundLineY - yOffset); 
      //float x3 = sin(radians(i))*(500/angle); 
      float x4 = sin(radians(i))*(500/angle); 
      float y4 = cos(radians(i))*(500/angle2);
      float x3 = round(cos(radians(i + 150)) * sphereRadius + center.x);
      //float y3 = cos(radians(i))*(500/angle);
      float y3 = round(sin(radians(i + 150)) * sphereRadius + groundLineY - yOffset);
      fill (0xFF00FFFF, 90); //blue
      circle(x3, y3, player.right.get(i)*70);
      fill (0xFFFFFFFF, 90); //white planet ring
      circle(x5, y5, player.right.get(i)*30);
    }
    
    int size = player.bufferSize();
    for (int i = 0; i < size-1; i++) {
       float angle = sin(i+var1)* 10; 
       float angle2 = sin(i+var2)* 300; 
    
       float x2 = round(sin(radians(i+150))*(angle2+30)* sphereRadius + center.x); 
       float y2 = round(cos(radians(i+150))*(angle2+30)* sphereRadius + groundLineY - yOffset);
        
       float x6 = round(sin(radians(i+150))*(800/angle)* sphereRadius + center.x); 
       float y6 = round(cos(radians(i+150))*(800/angle)* sphereRadius + groundLineY - yOffset);
       
       fill ( 0xFFFFFFFF, 90); //white
       circle(x2+200, y2-100, player.right.get(i)*90);
    }
    
    direction = !direction;
    surrCount += 1;
  }
  // Lines extending from sphere
  float extendingLinesMin = sphereRadius * 1.3f;
  float extendingLinesMax = sphereRadius * 3.5f; 
 
  float xDestination;
  float yDestination;
 
  for (int angle = 0; angle <= 240; angle++) {

    float extendingSphereLinesRadius = map(noise(angle * 0.3f), 0, 1, extendingLinesMin, extendingLinesMax);
 
    // Radius are mapped differently for highs, mids, and lows - alter higher mapping number for different result (eg. 0.8 to 0.2 in the highs)
    if (sum[0] != 0) {
      if (angle >= 0 && angle <= 30) {
        extendingSphereLinesRadius = map(sum[240 - round(map((angle), 0, 30, 0, 80))], 0, 0.8f, extendingSphereLinesRadius - extendingSphereLinesRadius / 8, extendingLinesMax * 1.5f); // Highs
      }
 
      else if (angle > 30 && angle <= 90) {
        extendingSphereLinesRadius = map(sum[160 - round(map((angle - 30), 0, 60, 0, 80))], 0, 3, extendingSphereLinesRadius - extendingSphereLinesRadius / 8, extendingLinesMax * 1.5f); // Mids
      }
 
      else if (angle > 90 && angle <= 120) {
        extendingSphereLinesRadius = map(sum[80 - round(map((angle - 90), 0, 30, 65, 80))], 0, 40, extendingSphereLinesRadius - extendingSphereLinesRadius / 8, extendingLinesMax * 1.5f); // Bass
      }
 
      else if (angle > 120 && angle <= 150) {
        extendingSphereLinesRadius = map(sum[0 + round(map((angle - 120), 0, 30, 0, 15))], 0, 40, extendingSphereLinesRadius - extendingSphereLinesRadius / 8, extendingLinesMax * 1.5f); // Bass
      }
 
      else if (angle > 150 && angle <= 210) {
        extendingSphereLinesRadius = map(sum[80 + round(map((angle - 150), 0, 60, 0, 80))], 0, 3, extendingSphereLinesRadius - extendingSphereLinesRadius / 8, extendingLinesMax * 1.5f); // Mids
      }
 
      else if (angle > 210) {
        extendingSphereLinesRadius = map(sum[160 + round(map((angle - 210), 0, 30, 0, 80))], 0, 0.8f, extendingSphereLinesRadius - extendingSphereLinesRadius / 8, extendingLinesMax * 1.5f); // Highs
      }
    }
    x = round(cos(radians(angle + 150)) * sphereRadius + center.x);
    y = round(sin(radians(angle + 150)) * sphereRadius + groundLineY - yOffset);

    xDestination = x;
    yDestination = y;

    for (int i = sphereRadius; i <= extendingSphereLinesRadius; i++) {
      int x2 = round(cos(radians(angle + 150)) * i + center.x);
      int y2 = round(sin(radians(angle + 150)) * i + groundLineY - yOffset);
 
      if (y2 <= getGroundY(x2)) { // Make sure it doesnt go into ground
        xDestination = x2;
        yDestination = y2;
      }
    }
    stroke(map(extendingSphereLinesRadius, extendingLinesMin, extendingLinesMax, 200, 255));
 
    if (y <= getGroundY(x) && y % 7 == 0)  {
      stroke(0xFF00FFBF , 200);//cool green; 
      line(x, y, xDestination, yDestination);
    } else {
      stroke(0xFF00FFFF , 200);//cool green; 
      line(x, y, xDestination, yDestination);
    }
  }
  
  // Ground line
    for (int groundX = 0; groundX <= width; groundX++) {
      float groundY = getGroundY(groundX);
      noStroke();
      //fill(255);
      if(groundX % 2 == 0){
        fill(0xFFFFFFFF , 200);
        circle(groundX, groundY, 1.8f * unit / 10.24f);
        noFill();
      } else {
        fill(0xFF00FFFF , 200);
        circle(groundX, groundY+20, 1.8f * unit / 10.24f);
        noFill();
      }
      groundY = getGroundY2(groundX);
      fill(0xFF00FFBF , 200);
      circle(groundX, groundY+30, 1.8f * unit / 10.24f);
      noFill();
    }

  //// Ground line
  //for (int groundX = 0; groundX <= width; groundX++) {

  //  float groundY = getGroundY(groundX);

  //  noStroke();
  //  fill(255);
  //  if(groundX % 2 == 0){
  //      fill(#ffffff , 200);
  //      circle(groundX, groundY, 1.8 * unit / 10.24);
  //    } else {
  //      fill(#00ffff , 200);
  //      circle(groundX, groundY+20, 1.8 * unit / 10.24);
  //    }
  //  //circle(groundX, groundY, 1.8 * unit / 10.24);
  //  //noFill();
  //}
}


// Get the Y position at position X of ground sine wave
 public float getGroundY(float groundX) {
  float angle = 1.1f * groundX / unit * 10.24f;
  float groundY = sin(radians(angle + frameCount * 2)) * unit * 1.25f + groundLineY - unit * 1.25f;
  return groundY;
}

 public float getGroundY2(float groundX) {
  float angle = 1.1f * groundX / unit * 10.24f;
  float groundY = cos(radians(angle + frameCount * 2)) * unit * 1.25f + groundLineY - unit * 1.25f;
  return groundY;
}

 public void draw(){
  fft.forward(player.mix);
  spectrum = new float[bands];
  for(int i = 0; i < fft.avgSize(); i++){
    spectrum[i] = fft.getAvg(i) / 2;
    // Smooth the FFT spectrum data by smoothing factor
    sum[i] += (abs(spectrum[i]) - sum[i]) * smoothingFactor;
  }
 
  // Reset canvas
  fill(0);
  noStroke();
  rect(0, 0, width, height);
  noFill();
  dashboard();
  drawAll(sum);
}

 public void mousePressed(){
  if(hide.isMouseOver()){
    smoothCanvas.getFrame().toBack();// Hide window
  }
  if(full.isMouseOver()){
    isInFullscreen = !isInFullscreen;
    if(isInFullscreen){
      smoothCanvas.getFrame().setLocation(0, 0);
      smoothCanvas.getFrame().setSize(displayWidth, displayHeight);
    }else{
      smoothCanvas.getFrame().setLocation(100, 100);
      smoothCanvas.getFrame().setSize(1080, 1080);
    }
  }
  if(close.isMouseOver()){
    exit();// Close window
  }
  // Drag window
  if(mouseY < 20){
    dragging = true;
    dragX = mouseX;
    dragY = mouseY;
  }
}

 public void mouseDragged(){
  if(dragging){
    // Get mouse position and move the window
    Point mouse = MouseInfo.getPointerInfo().getLocation();
    smoothCanvas.getFrame().setLocation(mouse.x - dragX, mouse.y - dragY);
  }
}

 public void mouseReleased(){
  dragging = false;
}

 public void dashboard(){
  background(0);
  // Draw Menu Bar
  fill(0);
  rect(0, 0, width, 20);
  hide.display();
  full.display();
  close.display();
}

// Menu Button Class
class Button{
  int xpos, ypos;
  int sizeX, sizeY;
  int buttonColor;
  int borderRadius;
  
  Button(int x, int y, int sx, int sy, int c, int br){
    xpos = x;
    ypos = y;
    sizeX = sx;
    sizeY = sy;
    buttonColor = c;
    borderRadius = br;
  }
  
   public void display(){
    fill(buttonColor);
    rect(xpos, ypos, sizeX, sizeY, borderRadius);
  }
  
   public boolean isMouseOver(){
    if(mouseX > xpos && mouseX < xpos + sizeX && mouseY > ypos && mouseY < sizeY){
      return true;
    }
    return false;
  }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Relaxed" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
